"""added blueprints

Revision ID: 47b8f28490b1
Revises: 875e85441cdc
Create Date: 2024-03-19 22:17:40.974032

"""
import sqlalchemy as sa
from alembic import op
from sqlalchemy import text
from sqlalchemy.orm import Session

# revision identifiers, used by Alembic.
revision = '47b8f28490b1'
down_revision = '875e85441cdc'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('blueprint',
    sa.Column('id', sa.SmallInteger(), nullable=False),
    sa.Column('name', sa.String(length=32), nullable=False),
    sa.Column('description', sa.String(length=256), nullable=False),
    sa.Column('cost', sa.Integer(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('blueprint_association',
    sa.Column('player_id', sa.BigInteger(), nullable=True),
    sa.Column('blueprint_id', sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(['blueprint_id'], ['blueprint.id'], ),
    sa.ForeignKeyConstraint(['player_id'], ['player.user_profile_id'], )
    )


    ## This is a bit tricky, when a building already exists, Postgres will complain about non-existing blueprints
    # in a non-null column. Therefore, we need to add a default value to the column, and then remove it
    # We also add the first blueprint to the db so we have an object to link /refer to

    session = Session(bind=op.get_bind())
    if len(session.execute(text("SELECT * FROM building")).fetchall()) != 0:
        print("WARNING: There are already buildings in the database. Linking these to a dummy blueprint. FIX THIS")

        op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (0, 'Dummy', 'Dummy', 0)")

        with op.batch_alter_table('placeable', schema=None) as batch_op:
            batch_op.add_column(sa.Column('blueprint_id', sa.SmallInteger(), nullable=False, server_default='0'))
            batch_op.create_foreign_key(None, 'blueprint', ['blueprint_id'], ['id'])

        # Remove the serverdefault value afterwards
        with op.batch_alter_table('placeable', schema=None) as batch_op:
            batch_op.alter_column('blueprint_id', server_default=None)

    else:
        # Normal migration, don't set the server default here
        with op.batch_alter_table('placeable', schema=None) as batch_op:
            batch_op.add_column(sa.Column('blueprint_id', sa.SmallInteger(), nullable=False))
            batch_op.create_foreign_key(None, 'blueprint', ['blueprint_id'], ['id'])


    # Now a bit of data migration
    # Populate the db with initial blueprints
    print("INFO Inserting default blueprints")
    # We need to do this with raw SQL as SQLAlchemy already knows there's a new column, but the DB doesn't have that column yet (as it's in a later migration)
    op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (1, 'Altar', 'The main hub of the island', 0)")
    op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (2, 'Mine', 'The mine of them all', 200)")
    op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (3, 'Tower', 'A simple defense tower', 300)")
    op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (4, 'FuseTable', 'Fuse crystals to create a gem', 500)")
    op.execute("INSERT INTO blueprint (id, name, description, cost) VALUES (5, 'WarriorHut', 'Spawns minons to attack enemies', 1000)")


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('placeable', schema=None) as batch_op:
        batch_op.drop_constraint('placeable_blueprint_id_fkey', type_='foreignkey')
        batch_op.drop_column('blueprint_id')

    op.drop_table('blueprint_association')
    op.drop_table('blueprint')
    # ### end Alembic commands ###
